/ scripts/football_data_api_pull_league_matches.go
package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"net/http"
	"net/url"
	"os"
	"strconv"
	"strings"
	"time"

	"winbet-ai/api/internal/database"

	"github.com/jmoiron/sqlx"
)

type matchesResponse struct {
	Success bool          `json:"success"`
	Data    []leagueMatch `json:"data"`
	Message string        `json:"message"`
}

type leagueMatch struct {
	ID             int64       `json:"id"`
	HomeID         int64       `json:"homeID"`
	AwayID         int64       `json:"awayID"`
	Season         string      `json:"season"`
	Status         string      `json:"status"`
	RoundID        interface{} `json:"roundID"`
	GameWeek       interface{} `json:"game_week"`
	HomeGoalCount  int         `json:"homeGoalCount"`
	AwayGoalCount  int         `json:"awayGoalCount"`
	TotalGoalCount int         `json:"totalGoalCount"`
	DateUnix       int64       `json:"date_unix"`
	WinningTeam    int64       `json:"winningTeam"`
	NoHomeAway     int         `json:"no_home_away"`
	OddsFT1        float64     `json:"odds_ft_1"`
	OddsFTX        float64     `json:"odds_ft_x"`
	OddsFT2        float64     `json:"odds_ft_2"`
}

func main() {
	var seasonID int
	var maxPerPage int
	var startPage int

	flag.IntVar(&seasonID, "season-id", 0, "league season_id (required)")
	flag.IntVar(&maxPerPage, "max-per-page", 1000, "max matches per page (max 1000)")
	flag.IntVar(&startPage, "page", 1, "start page")
	flag.Parse()

	if seasonID == 0 {
		fmt.Fprintln(os.Stderr, "season-id is required")
		os.Exit(1)
	}

	apiKey := os.Getenv("FOOTBALL_DATA_API_KEY")
	if apiKey == "" {
		fmt.Fprintln(os.Stderr, "FOOTBALL_DATA_API_KEY is required")
		os.Exit(1)
	}

	baseURL := os.Getenv("FOOTBALL_DATA_API_BASE_URL")
	if baseURL == "" {
		baseURL = "https://api.football-data-api.com"
	}

	dbURL := os.Getenv("PREDICTIONS_DATABASE_URL")
	if dbURL == "" {
		fmt.Fprintln(os.Stderr, "PREDICTIONS_DATABASE_URL is required")
		os.Exit(1)
	}

	db, err := database.New(dbURL)
	if err != nil {
		fmt.Fprintf(os.Stderr, "failed to connect to predictions DB: %v\n", err)
		os.Exit(1)
	}
	defer db.Close()

	client := &http.Client{Timeout: 45 * time.Second}
	total := 0

	for page := startPage; ; page++ {
		endpoint, err := buildURL(baseURL, apiKey, seasonID, maxPerPage, page)
		if err != nil {
			fmt.Fprintf(os.Stderr, "failed to build url: %v\n", err)
			os.Exit(1)
		}

		payload, err := fetchPage(client, endpoint)
		if err != nil {
			fmt.Fprintf(os.Stderr, "failed to fetch page %d: %v\n", page, err)
			break
		}

		if !payload.Success {
			fmt.Fprintf(os.Stderr, "api error page %d: %s\n", page, payload.Message)
			break
		}

		if len(payload.Data) == 0 {
			break
		}

		for _, match := range payload.Data {
			raw, _ := json.Marshal(match)
			if err := upsertMatch(db, seasonID, match, raw); err != nil {
				fmt.Fprintf(os.Stderr, "failed to upsert match %d: %v\n", match.ID, err)
				continue
			}
			total++
		}

		fmt.Printf("Upserted %d matches through page %d\n", total, page)
	}

	fmt.Printf("Upserted %d matches total\n", total)
}

func buildURL(baseURL, apiKey string, seasonID int, maxPerPage int, page int) (string, error) {
	values := url.Values{}
	values.Set("key", apiKey)
	values.Set("season_id", strconv.Itoa(seasonID))
	if maxPerPage > 0 {
		values.Set("max_per_page", strconv.Itoa(maxPerPage))
	}
	if page > 1 {
		values.Set("page", strconv.Itoa(page))
	}
	return fmt.Sprintf("%s/league-matches?%s", strings.TrimRight(baseURL, "/"), values.Encode()), nil
}

func fetchPage(client *http.Client, url string) (*matchesResponse, error) {
	req, err := http.NewRequest(http.MethodGet, url, nil)
	if err != nil {
		return nil, err
	}

	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode < 200 || resp.StatusCode > 299 {
		return nil, fmt.Errorf("status %d", resp.StatusCode)
	}

	var payload matchesResponse
	if err := json.NewDecoder(resp.Body).Decode(&payload); err != nil {
		return nil, err
	}

	return &payload, nil
}

func upsertMatch(db *sqlx.DB, seasonID int, match leagueMatch, raw []byte) error {
	roundID := stringify(match.RoundID)
	gameWeek := stringify(match.GameWeek)
	query := `
		INSERT INTO football_data_api_league_matches (
			match_id, season_id, home_id, away_id, status, round_id, game_week,
			home_goal_count, away_goal_count, total_goal_count, date_unix,
			winning_team, no_home_away, odds_ft_1, odds_ft_x, odds_ft_2, raw
		) VALUES (
			$1,$2,$3,$4,$5,$6,$7,
			$8,$9,$10,$11,
			$12,$13,$14,$15,$16,$17
		)
		ON CONFLICT (match_id) DO UPDATE SET
			season_id = EXCLUDED.season_id,
			home_id = EXCLUDED.home_id,
			away_id = EXCLUDED.away_id,
			status = EXCLUDED.status,
			round_id = EXCLUDED.round_id,
			game_week = EXCLUDED.game_week,
			home_goal_count = EXCLUDED.home_goal_count,
			away_goal_count = EXCLUDED.away_goal_count,
			total_goal_count = EXCLUDED.total_goal_count,
			date_unix = EXCLUDED.date_unix,
			winning_team = EXCLUDED.winning_team,
			no_home_away = EXCLUDED.no_home_away,
			odds_ft_1 = EXCLUDED.odds_ft_1,
			odds_ft_x = EXCLUDED.odds_ft_x,
			odds_ft_2 = EXCLUDED.odds_ft_2,
			raw = EXCLUDED.raw,
			updated_at = NOW()
	`

	_, err := db.Exec(query,
		match.ID, seasonID, match.HomeID, match.AwayID, match.Status, roundID, gameWeek,
		match.HomeGoalCount, match.AwayGoalCount, match.TotalGoalCount, match.DateUnix,
		match.WinningTeam, match.NoHomeAway, match.OddsFT1, match.OddsFTX, match.OddsFT2, raw,
	)
	return err
}

func stringify(v interface{}) string {
	switch val := v.(type) {
	case nil:
		return ""
	case string:
		return val
	case float64:
		if val == float64(int64(val)) {
			return fmt.Sprintf("%d", int64(val))
		}
		return fmt.Sprintf("%f", val)
	case json.Number:
		return val.String()
	default:
		return fmt.Sprintf("%v", val)
	}
}
